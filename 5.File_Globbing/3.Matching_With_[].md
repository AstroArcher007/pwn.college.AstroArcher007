# Matching with []

The challenge was to use the `[]` globbing wildcard to provide the correct file as an argument to an executable.

-----

## My Solve

**Flag:** `pwn.college{sKIYt8U5u3JACwKnW8zobWk9UzT.QXzIDO0wSO0AzNzEzW}`

1.  Navigated to the `/challenge/files` directory and listed its contents.
2.  Initially tried to run a local `run` executable, which failed as it was not in the current directory.
3.  Used the `[]` globbing pattern to match a set of characters. `file_[bash]` expands to match any file starting with `file_` and ending with `b`, `a`, `s`, or `h`.
4.  Provided the matched file as an argument to the correct executable located at `/challenge/run`.
5.  Flag captured.

<!-- end list -->

```bash
hacker@globbing~matching-with-:~$ cd /challenge/files
hacker@globbing~matching-with-:/challenge/files$ ls
file_a  file_c  file_e  file_g  file_i  file_k  file_m  file_o  file_q  file_s  file_u  file_w  file_y
file_b  file_d  file_f  file_h  file_j  file_l  file_n  file_p  file_r  file_t  file_v  file_x  file_z
hacker@globbing~matching-with-:/challenge/files$ ./run [bash]
bash: ./run: No such file or directory
hacker@globbing~matching-with-:/challenge/files$ ./run file_[bash]
bash: ./run: No such file or directory
hacker@globbing~matching-with-:/challenge/files$ /challenge/run file_[bash]
You got it! Here is your flag!
pwn.college{sKIYt8U5u3JACwKnW8zobWk9UzT.QXzIDO0wSO0AzNzEzW}
```

-----

## What I learned

The `[...]` wildcard in shell globbing matches any **single character** that is present within the brackets. It's a way to specify a set of possible characters for a single position in a filename.

-----

## References

NONE.